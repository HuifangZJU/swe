# C++内存中的字节对齐

## 字节对齐原因和作用

1. 不按照平台要求对数据存放进行对齐，会带来存取效率上的损失，通过合理的内存对齐可以提高访问效率。

> 比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。

2. 此外，合理利用字节对齐还可以有效地节省存储空间。

> 但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。

## 字节对齐规则

### 结构体字节对齐

1. 数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节，指针类型4个字节(32位)/8个字节(64位)

2. **结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。**

3. 指定对齐值：#pragma pack (value)时的指定对齐值value。

4. 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。

### 栈内存对齐

在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。

## VS中查看类的内存布局
在项目->属性->C/C++->命令行中添加
```bash
/d1 reportAllClassLayout
```
或者
```bash
/d1 reportSingleClassLayoutXXX
```
其中XXX代表类名

## 例子

```cpp
struct Test{
union {
    int a;
    double b;
};

char c;
char d;
short e;

int f;

char g[5];

float h;
};
```

这个struct算下来是28个字节，但是由于最大的数据类型是double，所以要8字节对齐，故实际大小是32字节。
