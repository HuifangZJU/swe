# 排序算法

## 快排
* 思想：分治
* 复杂度: 最佳$O(nlog_n)$，最差$O(n^2)$，最差情况发生在排序数组有序
~~线程池实现非递归快排~~

## 常见排序算法的实现以及稳定性
* **冒泡排序**
冒泡排序就是把小的元素往前调（或者把大的元素往后调）。注意是相邻的两个元素进行比较，而且是否需要交换也发生在这两个元素之间。相同元素经过排序后顺序并没有改变。**稳定**

* 选择排序
选择排序即是给每个位置选择待排序元素中当前最小的元素。序列5 8 5 2 9， 我们知道第一趟选择第1个元素5会与2进行交换，那么原序列中两个5的相对先后顺序也就被破坏了。**不稳定**

* **插入排序**
插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。**稳定**

* 快速排序
快速排序有两个方向，左边的i下标一直往右走（当条件a[i] <= a[pivot_index]时），而右边的j下标一直往左走（当a[j] > a[pivot_index]时）。如果i和j都走不动了且i <= j, 则交换a[i]和a[j],重复上面的过程，直到i>j。交换a[j]和a[pivot_index]，完成一趟快速排序。
在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11 ，现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱。**不稳定**

* **归并排序**
归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换)，然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。**稳定**

* **基数排序**
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。**稳定**

* 希尔排序
希尔排序是按照不同步长对元素进行插入排序。当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序时，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(N^2)好一些。
由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序；但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。**不稳定**

* 堆排序
我们知道堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。
在一个长为n的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n/2-1, n/2-2, ...1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。**不稳定**

![排序算法时间/空间复杂度及稳定性](http://7xnluw.com1.z0.glb.clouddn.com/Algorithm/sort_algorithm.jpg)
